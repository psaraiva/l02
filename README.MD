# Desafio de Observabilidade com OpenTelemetry

Este projeto consiste em um sistema distribu√≠do de dois servi√ßos em Go que, juntos, fornecem a temperatura atual de uma localidade a partir de um CEP (C√≥digo de Endere√ßamento Postal). Toda a comunica√ß√£o entre os servi√ßos e com as APIs externas √© instrumentada com **OpenTelemetry** para garantir observabilidade completa, com traces visualizados no **Jaeger**.

<p align="center">
  <img src="https://opentelemetry.io/img/logos/opentelemetry-logo-nav.png" width="300" alt="OpenTelemetry Logo">
  &nbsp;&nbsp;&nbsp;&nbsp;
  <img src="https://www.jaegertracing.io/img/jaeger-logo-color.png" width="200" alt="Jaeger Logo">
</p>

---

## Arquitetura

O sistema √© composto por dois microservi√ßos e o Jaeger, orquestrados via Docker Compose:

1.  **`app1` (Servi√ßo de Entrada)**:
    *   Recebe as requisi√ß√µes do cliente com o CEP.
    *   Valida o formato do CEP.
    *   Chama o `app2` para obter os dados de clima.
    *   √â a porta de entrada do sistema, escutando na porta `8080`.

2.  **`app2` (Servi√ßo Orquestrador)**:
    *   Recebe o CEP validado do `app1`.
    *   Consulta a API **ViaCEP** para obter a cidade correspondente.
    *   Consulta a API **WeatherAPI** para obter a temperatura da cidade.
    *   Retorna os dados consolidados para o `app1`.

3.  **`jaeger`**:
    *   Recebe e armazena os dados de telemetria (traces) enviados pelos servi√ßos via OTLP.
    *   Fornece uma interface web para visualiza√ß√£o e an√°lise dos traces distribu√≠dos.

O fluxo da requisi√ß√£o √© o seguinte:
`Cliente -> app1 -> app2 -> (ViaCEP & WeatherAPI) -> app2 -> app1 -> Cliente`

## ‚ú® Features

- **Sistema Distribu√≠do**: Arquitetura baseada em dois microservi√ßos Go.
- **Observabilidade Completa**: Instrumenta√ß√£o com OpenTelemetry e visualiza√ß√£o de traces no Jaeger.
- **Valida√ß√£o de CEP**: Garante que apenas CEPs no formato `XXXXX-XXX` sejam processados.
- **Orquestra√ß√£o de APIs**: Integra√ß√£o com ViaCEP e WeatherAPI.
- **Resposta em JSON**: Retorna a cidade e as temperaturas em Celsius, Fahrenheit e Kelvin.
- **Containeriza√ß√£o**: Pronto para deploy com Docker e Docker Compose.

## ‚öôÔ∏è Pr√©-requisitos

- **Go 1.24** ou superior (para execu√ß√£o local).
- **Docker** e **Docker Compose**.
- **API Key** do WeatherAPI.com.

## üöÄ Execu√ß√£o

Existem duas maneiras principais de executar o projeto: a forma recomendada, utilizando Docker Compose para toda a stack, ou um modo h√≠brido para desenvolvimento.

### M√©todo 1: Docker Compose (Recomendado)

Esta √© a forma mais simples de subir todos os servi√ßos (`app1`, `app2`, e `jaeger`) de uma vez.

1.  **Clone o reposit√≥rio:**
    ```bash
    git clone git@github.com:psaraiva/l02.git
    cd l02
    ```

3.  **Configure a API Key:**
    Crie um arquivo chamado `.env` dentro da pasta `app2` (`app2/.env`) e adicione sua chave da WeatherAPI:
    ```
    WEATHER_API_KEY="sua_chave_api_aqui"
    ```

4.  **Execute a stack com Docker Compose:**
    ```bash
    docker-compose up -d
    ```
    Os servi√ßos estar√£o dispon√≠veis nos seguintes endere√ßos:
    - **Servi√ßo de Clima (`app1`)**: `http://localhost:8080`
    - **Servi√ßo Orquestrador (`app2`)**: `http://localhost:8083`
    - **Jaeger UI**: `http://localhost:16686`

### M√©todo 2: H√≠brido (Go Local + Jaeger em Docker)

Este m√©todo √© ideal para desenvolvimento, pois permite executar o c√≥digo Go localmente enquanto utiliza o Jaeger via Docker.

1.  **Clone o reposit√≥rio e configure a API Key** conforme os passos 1 e 2 do m√©todo anterior.

2.  **Inicie o Jaeger com Docker Compose:**
    ```bash
    docker-compose up -d jaeger
    ```
    Isso iniciar√° apenas o cont√™iner do Jaeger.

3.  **Execute o `app2` (Servi√ßo Orquestrador):**
    Abra um novo terminal, navegue at√© a pasta do `app2` e execute:
    ```bash
    cd app2
    go run main.go
    ```
    O servi√ßo `app2` iniciar√° na porta `8083`.

4.  **Execute o `app1` (Servi√ßo de Entrada):**
    Abra outro terminal, navegue at√© a pasta do `app1` e execute:
    ```bash
    cd app1
    go run main.go
    ```
    O servi√ßo `app1` iniciar√° na porta `8080`.

## üì° Uso da API

As requisi√ß√µes devem ser feitas para o `app1`.

### Endpoint

`POST /weather-by-cep`

### Corpo da Requisi√ß√£o (JSON)

```json
{
    "cep": "01001-000"
}
```

### Exemplo de Requisi√ß√£o com `curl`

```bash
curl --location 'http://localhost:8080/weather-by-cep' \
--header 'Content-Type: application/json' \
--data '{
    "cep": "01001-000"
}'
```

### Exemplo de Resposta de Sucesso (200 OK)

```json
{
    "city": "S√£o Paulo",
    "temp_C": 21.0,
    "temp_F": 69.8,
    "temp_K": 294.15
}
```

### Respostas de Erro

**`400 Bad Request`**: Se o par√¢metro CEP n√£o for fornecido.
```
par√¢metro 'cep' √© obrigat√≥rio
```
**`422 Unprocessable Entity`**: Se o formato do CEP for inv√°lido.
```
CEP inv√°lido
```
**`404 Not Found`**: Se o CEP for v√°lido, mas n√£o for encontrado na API ViaCEP.
```
CEP n√£o encontrado
```
**`500 Internal Server Error`**: Se ocorrer um erro interno no servidor (por exemplo, uma falha ao contatar as APIs externas).
```
ocorreu um erro ao processar sua requisi√ß√£o
```

## üßê Jaeger

A instrumenta√ß√£o com OpenTelemetry √© um dos pilares deste projeto, permitindo visualizar o ciclo de vida completo de uma requisi√ß√£o em um **trace distribu√≠do**. Isso √© fundamental para depurar e entender a performance do sistema, mostrando como uma √∫nica chamada na `app1` se propaga pela `app2` at√© as APIs externas.

A imagem abaixo ilustra este fluxo, detalhando cada etapa e sua respectiva lat√™ncia:

![Exemplo de Trace Distribu√≠do no Jaeger](doc/jaeger-example.png)
